# Orchestration

In step 3, I focused on setting up orchestration for the application using **Kubernetes**.

## Introduction

Orchestration is the process of managing and coordinating multiple containers and services in a production environment. Kubernetes is a powerful orchestration tool that allows developers to deploy, scale, and manage containerized applications efficiently.

### Objective

My objective was to use Helm, a package manager for Kubernetes, to create reusable and maintainable deployment configurations for the application. This allows for easy deployment and management of the application in a Kubernetes cluster.

![Helm](./resources/3.1.helm.png)

## Process

Using plain Kubernetes manifests can be cumbersome and error-prone, especially as the application grows in complexity. By choosing Helm, I was able to create a Helm chart that encapsulates all the necessary Kubernetes resources for the application, such as Deployments, Services, and Ingresses.

### Configuration

I created a simple Helm chart which includes:
- **mern-client**:
  - A Deployment for the frontend service, which defines the container image, replicas, and resource limits.
  - An optional HPA (Horizontal Pod Autoscaler) for the frontend service, which automatically scales the number of replicas based on CPU usage.
  - A service for the frontend, which exposes it to the cluster.
- **mern-server**:
  - A Deployment for the backend service, which defines the container image, replicas, and resource limits.
  - An optional HPA for the backend service, which automatically scales the number of replicas based on CPU usage.
  - A secret for the backend, which stores sensitive information such as database credentials.
  - A service for the backend, which exposes it to the cluster.
- **python-script**:
  - A CronJob for the Python script, which schedules it to run at specified intervals.
- **ingress**:
  - An ALB Ingress resource to route external traffic to the frontend and backend services.

These resources are defined in the `templates` directory of the Helm chart, and the values for the resources are defined in the `values.yaml` file. Environment specific configurations are defined in separate files in the helm directory, such as `values-staging.yaml` and `values-production.yaml`.

Some sensitive information, such as AWS and MongoDB credentials, are passed with `--set` during deployment to avoid hardcoding them in the Helm chart.

### Usage

Deployment will be handled by CI/CD pipeline, which will use the Helm chart to deploy the application to the Kubernetes cluster. The pipeline will be configured to deploy to different environments (staging and production) based on the branch being pushed. For example, pushing to the `main` branch will trigger a deployment to the production environment, while pushing to a `develop` branch will trigger a deployment to the staging environment.

> **Note**: Because AWS' ALB wants same health check path for all services, I changed the health check path for the backend service to `/health` from `/healthcheck` to allow ALB to acquire health status of both services.
